---
title: Object-Oriented Programming (OOP) Notes
date: 2021-07-29 09:00:00 +1000
categories: [Programming, OOP]
tags: [object-oriented programming, design patterns, java, uml, design principles, mvc]
description: "Detailed notes on object-oriented programming, covering concepts such as inheritance, polymorphism, design principles, UML diagrams, design patterns, and Javafx for project work."
---

## 1. Object Oriented Programming (OOP)

Procedural Programming

- tends to be action-oriented
- groups of actions that perform some task are formed into functions and functions are grouped to form programs

Object Oriented Programming

- class -> user-defined type
  - class = data + methods (procedures) that manipulate the data
- object -> an instance of a class
  - objects have the property of information hiding
- OOP encapsulates data (attributes) and methods (behaviours) into objects
  - data and methods of an object are intimately tied together.

---

### 1.1 About Java

`JRE` -> Java Runtime Environment

`JVM` -> Java Virtual Machine

- translate Java Bytecode (Java code after compiling) into native code underlying Operating System
- making Java code platform independent (C# & Python have same architecture)

Java Edition

- Java Standard Edition (SE)
  - the core Java platform
  - contains all of the libraries that every Java developer must learn
- Java Enterprise Edition (EE)
  - used for building very large scale, distributed systems
  - built on top of Java SE and provides additional libraries for building fault-tolerant, distributed, multi-tier software
- Java Micro Edition (ME)
  - a subset of Java SE, designed for mobile devices
  - has libraries specific to mobile devices
- Java Card:
  - used in smart cards

---

### 1.2 Classes and Objects

- A `class` is a collection of data and methods (procedures) that operate on that data
- `objects` are created by instantiating a class

---

### 1.3 Inheritance

`Inheritance` is a form of software reusability in which new classes are created from the existing classes by absorbing their attributes and behaviours

- **_subclass_**(new class) can inherit attributes(variables) and behaviours(methods) from **_superclass_**(existing class)
  - `single inheritance` -> a new class can extend only one superclass
  - every class has a `superclass`, by default is the class **Object**
  - `Object Class` -> only class without superclass, methods defined by Object can be called by any Java object (instance)
- more attributes and behaviours can be added to _subclass_
- inheritance relationships form `tree-like hierarchical` structures
- Keyword `extends` and `super`

---

#### Inheritance Relationship - `Is-a`

- an object of a subclass may also be treated as an object of the
  superclass
- use inheritance to model “is-a” relationship
- only use inheritance when all or most inherited attributes and methods make sense
<details><summary>example</summary>
<p>

mathematically a circle is-a (an) oval, however you should not inherit a class circle from a class oval. A class oval can have one method to set width and another to set height.

</p>
</details>

---

#### Association Relationship - `Has-a`

- a class object has an object of another class to store its state or do its work, it “has-a” reference to that other object
  - eg. a Rectangle Is-NOT-a Line, but can use a Line to draw a Rectangle
- creating new classes by composition of existing classes (as oppose to extending classes), method forwarding

---

### 1.4 Abstraction

- data abstraction is the process of hiding certain details and showing only essential information to the user
- can be achieved with either **abstract** `classes` or `interfaces`

---

#### Abstract Class

- declare classes that define only part of an implementation, leaving extended classes to provide specific implementation of some or all the methods
  - if a class includes abstract methods, then the class itself must be declared abstract
  - an abstract class cannot be instantiated
  - a `subclass` of an abstract class can be instantiated if it overrides each of the abstract methods of its superclass and provides an implementation for all of them
  - if a `subclass` of an abstract class does not implement all the abstract methods it inherits, that subclass is itself abstract
- programmer knows the interface definition of an object
  - methods can be implemented differently in different subclasses of the abstract class

---

#### Interface

- A list of variables and methods
  - variables must be static and final (constants)
  - methods are implicitly abstract
- can be use to add multiple inheritance
- in other class, access interface with `implement` keywords
  - must provide an implementation for all of the abstract methods of the interface
  - a class can implements >1 interfaces
- interface can have `sub-interface`
  - `sub-interface` inherits all abstract methods and constants from `super-interface`
  - `sub-interface` may define new abstract methods and constants
  - interfaces can extend more than one interface at a time

---

### 1.5 Encapsulation

- Encapsulation ensures that an object’s state is in a consistent state
- Encapsulation increases usability
  - Keeping the data private and exposing the object only through its interface (public methods) provides a clear view of the role of the object and increases usability
  - Clear contract between the invoker and the provider, where the client agrees to invoke an object’s method adhering to the method signature and provider guarantees consistent behaviour of the method invoked (if the client invoked the method correctly)
- Encapsulation abstracts the implementation, reduces the dependencies so that a change to a class does not cause a rippling effect on the system

Visibility Modifiers

- public -> visible to the world
- protected -> visible to the package and all subclasses
- No modifier (default) -> visible to the package
- private -> visible to the class only

---

### 1.6 Polymorphism

- An object’s ability to decide what method to apply to itself, depending on where it is in the inheritance hierarchy
- Overriding a method -> method with same name and same parameters, execute only the last declared method
- Overloading a method -> Can have multiple methods with the same name but different parameters

---

#### Method Overriding

- a class defines a method using the same name, return type,
  and by the number, type, and position of its arguments as a method in its superclass
- if a method is invoked for an object of the class, it’s the new definition of the method that is called, and not the superclass’s old definition
- refer to the overridden method using `super` keyword

---

#### Method Overloading

- defining methods with the same name and different argument or return types is called method overloading

---

### 1.5 Method Forwarding

- forwarding means that using a member of an object (either a property or a method) results in actually using the corresponding member of a different object: the use is forwarded to another object
- Forwarding is used in a number of design patterns, where some members are forwarded to another object, while others are handled by the directly used object
- The forwarding object is frequently called a wrapper object, and explicit forwarding members are called wrapper functions

---

### 1.6 Constructors

- Good practice to define the required constructors for all classes.
- If a constructor is not defined in a class,
  - no-argument constructor is implicitly inserted.
  - this no-argument constructor invokes the superclass’s no-argument constructor.
  - if the parent class (superclass) doesn’t have a visible constructor with no-argument, it results in a compilation error.
- If the first statement in a constructor is not a call to super() or this(), a call to super () is implicitly inserted.
- If a constructor is defined with one or more arguments, no-argument constructor is not inserted in that class.
- A class can have multiple constructors, with different signatures.
- The word “this” can be used to call another constructor in the same class.

---

## 2. Unified Modelling Language (UML)

- `Requirements analysis` determines _external behaviour_
  - “What are the features of the system-to-be and who requires these features (actors) ”
- `Domain modelling` determines _internal behavior_
  - “how elements of system-to-be interact to produce the external behaviour”
- `Requirements analysis` and `domain modelling` are **_mutually dependent_**

  - domain modelling supports clarification of requirements, whereas requirements help building up the model.

- `Domain` – A sphere of knowledge particular to the problem being solved

---

### 2.1 Domain Models / Conceptual Models / Domain Object Models

- used to visually represent important domain concepts and relationships between them
  - help clarify and communicate important domain specific concepts and are used during the requirements gathering and designing phase
- `domain modeling` is the activity of expressing related domain concepts into a domain model.
- `Unified Modeling Language (UML)` class diagrams to represent domain
  models

---

### 2.2 Ubiquitous Language

- technical details do not form part of the domain model as they are not part of the design
  - `nouns` -> possible entities (class/object)
  - `verbs` -> possible behaviours (method)
- `attributes` vs. `classes`
  - if a concept is not representable by a number or a string, most likely it is a `class`

---

### 2.3 Symbols

- Visibility
  - `-` private
  - `+` public
  - `#` protected
  - `~` package/default
- Relationships (lines)
  - `single line` association
    - a class "uses" another class in some way, when undirected, it is not yet clear in what direction dependency occurs
  - `single line + arrow` directed association
    - refines association by indicating which class has knowledge of the other
  - `dash line + arrow` dependency
    - the loosest form of relationship, class in some way depends on another
  - `single line + hollow diamond` aggregation
    - a class contains another class, the contained item is an element of a collection but it can also exist on its own
  - `single line + solid diamond` composition
    - the contained item is an integral part of the containing item, and cannot exist on its own
  - `single line + hollow triangle` inheritance
- Multiplicity
  - `0..1` zero or one(optional)
  - `n` specific number
  - `0..*` zero to many
  - `1..*` one to many
  - `m..n` specific number range

---

## 3. Design

---

### 3.1 Design Smells (poor design)

- `Rigidity`
  - tendency of the software being too difficult to change even in simple ways
  - a single change causes a cascade of changes to other dependent modules
- `Fragility`
  - tendency of the software to break in many places when a single change is made
  - `rigidity` and `fragility` complement each other – aim towards minimal impact, when a new feature or change is needed
- `Immobility`
  - design is hard to reuse
  - design has parts that could be useful to other systems, but the effort needed and risk in disentangling the system is too high
- `Viscosity`
  - software viscosity – changes are easier to implement through ‘hacks’ over ‘design preserving methods’
  - environment viscosity – development environment is slow and in-efficient
- `Opacity`
  - tendency of a module to be difficult to understand
  - code must be written in a clear and expressive manner
- `Needless complexity`
  - contains constructs that are not currently useful
  - developers ahead of requirements
- `Needless repetition`
  - design contains repeated structures that could potentially be unified under a single abstraction
  - bugs found in repeated units have to be fixed in every repetition

---

### 3.2 Good Design

Good software aims for building a system with **_loose coupling_** and **_high cohesion_** among its components so that software entities are:

- Extensible
- Reusable
- Maintainable
- Understandable
- Testable

Good Software Design

- Separation of Concerns (SOC) - Djikstra, 1974
- Design Patterns (GOF)
- Pragmatic Programming
  - `DRY` (Don't Repeat Yourself)
  - `KISS` (keep it simple, stupid!)
- Less Fragile Systems
- SOLID Principles
  - `Single responsibility principle`: A class should only have a single responsibility.
  - `Open–closed principle`: Software entities should be open for extension, but closed for modification.
  - `Liskov substitution principle`: Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.
  - `Interface segregation principle`: Many client-specific interfaces are better than one general-purpose interface.
  - `Dependency inversion principle`: One should "depend upon abstractions, [not] concretions.”

---

#### Coupling

- is defined as the degree of **_interdependence_** between components or classes
- **_high coupling_** occurs when one component `A` depends on the internal workings of another component `B` and is affected by internal changes to component `B`
  - leads to a complex system, with difficulties in maintenance and extension, eventual software rot
- aim for **_loosely coupled_** classes - allows components to be used and modified independently of each other
- **_“zero-coupled”_** classes are not usable

---

#### Cohesion

- the degree to which all elements of a component or class or module work together as a functional unit
- **_Highly cohesive_** modules are:
  - much easier to maintain
  - less frequently changed
  - higher probability of reusability
- **_do not put all the responsibility into a single class_** to avoid low cohesion

---

### 3.3 Design Principles

- **_Favour composition over inheritance_**
  - If you favour delegation, composition over inheritance, your software will be more flexible, easier to maintain, extend
    - `Delegation` – delegate the functionality to another class
    - `Composition` – reuse behaviour using one or more classes with composition
- design principles
  - encapsulate what varies
  - compose and delegate
- Refactoring Techniques that support these principles
  - Replace Type Code with Strategy/State Pattern
  - Replace conditional logic with polymorphism

---

#### Design Principle 1

`The Principle of Least Knowledge` / `Law of Demeter`

- classes should know about and interact with as few classes as possible
- helps to design“ loosely coupled” systems so that changes to one part of the system does not cascade to other parts of the system
- A method in an object should only invoke methods of:
  - the object itself
  - the object passed in as a parameter to the method
  - objects instantiated within the method
  - any component objects
  - not those of objects returned by a method
- limits interaction through a set of rules
  1. A method `M` in an object `O` can call on any other method within `O` itself


      - a method encapsulated within a class can call any other method that is also encapsulated within the same class
  2. A method `M` in an object `O` can call on any methods of parameters passed to the method `M`


      - parameter is local to the method
  3. A method `M` can call a method `N` of another object, if that object is instantiated within the method `M`


      - The object instantiated is considered “local” just as the object passed in as a parameter
  4. Any method `M` in an object `O` can call on any methods of any type of object that is a direct component of `O`


      - a method of a class can call methods of classes of its instance variables

---

#### Design Principle 2

`Liskov Substitution Priciple (LSP)`

- LSP is about **_well-designed inheritance_**
  - subtypes must be substitutable for their base types

---

##### Rules for Method Overriding

- The access level cannot be **_more restrictive_** than the overridden method’s access level
  - if the super class method is declared `public` then the overriding method in the sub class cannot be either `private` or `protected`
- can be overridden
  - methods with argument list exactly the same as that of the overridden method
- cannot be overridden
  - `static` methods
  - `constructors`
  - `final` methods
- Covariance of return types in the overridden method
  - The return type in the overridden method should be the same or a sub-type of the return type defined in the super-class
  - This means that return types in the overridden method may be narrower than the parent return types

---

##### Refactoring

- The process of restructuring (changing the internal structure of software) software to make it easier to understand and cheaper to modify without changing its external, observable behaviour
- Refactoring is an **iterative** cycle of making a small program **transformation**, **testing** it to ensure correctness, and making another small **transformation**
- advantages
  - improve design of software
  - improved code readability
  - helps to find bugs
  - reduced complexity
  - improved maintenance and extensibility
  - helps to conform design principles and avoid design smells
- when to use
  - add a function
  - need to fix a bug
  - during code review

> <details><summary>Low-level refactoring</summary>
> <p>
>
> - Names:
>   - Renaming (methods, variables)
>   - Naming (extracting) “magic” constants
> - Procedures:
>   - Extracting code into a method
>   - Extracting common functionality (including duplicate code) into a class/method/etc.
>   - Changing method signatures
> - Reordering:
>   - Splitting one method into several to improve cohesion and readability (by reducing its size)
> - Putting statements that semantically belong together near each other
>
> </p>
> </details>

> <details><summary>IDEs support low-level refactoring</summary>
> <p>
>
> - Renaming:
>   - Variable, method, class
> - Extraction:
>   - Method, constant
>   - Repetitive code snippets
>   - Interface from a type
> - Inlining: method, etc
> - Change method signature
> - Warnings about inconsistent code
>
> </p>
> </details>

> <details><summary>Higher-level refactoring</summary>
> <p>
>
> - Refactoring to **design patterns**
> - Changing language idioms (safety, brevity)
> - Performance optimization
> - Generally high-level refactoring is **much more important**, but unfortunately not well-supported by tools
>
> </p>
> </details>

> <details><summary>definition</summary>
> <p>
>
> “A change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior... It is a disciplined way to clean up code that minimizes the chances of introducing bugs.” - Martin Fowler & Kent Beck
>
> </p>
> </details>

---

#### Design Principle 3

Identify aspects of the code that varies, `encapsulate` and separate it from code that stays the same

- so that it won’t affect the real code

---

#### Design Principle 4

Program to a an interface (super-type), not to an implementation

- the declared type of the variable should be a super-type (abstract class or interface)
  ```java
  // programming to an implementation
  Dog d = new Dog();
  d.bark();
  // programming to an interface
  Animal a = new Dog();
  a. makeSound();
  ```

---

#### Design Principle 5

favour `composition` over `inheritance`

- Instead of inheriting behaviour, the classes get their behaviour by being `composed` with the right behaviour objects and `delegate` to the behaviour objects
  - allows you to encapsulate a family of algorithms
  - enables you to “change behaviour” at run-time

---

## 4. Design Pattern

- A design pattern is a tried solution to a commonly recurring problem
- Original use comes from a set of 250 patterns formulated by Christopher Alexander et al for architectural (building) design
- Every pattern has
  - A short name
  - A description of the context
  - A description of the problem
  - A prescription for a solution
- design pattern is
  - Represents a template for how to solve a problem
  - Captures design expertise and enables this knowledge to be transferred and reused
  - Provide shared vocabularies, improve communications and eases implementation
  - Is not a finished solution, they give you general solutions to design problems

---

### 4.1 Behavioural Patterns

Behavioural design patterns are design patterns that **identify common communication patterns** among objects and realise these patterns. By doing so, these patterns **increase flexibility** in carrying out this communication

#### [Strategy Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-strategy-pattern-notes.md %})

#### [State Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-state-pattern-notes.md %})

#### [Observer Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-observer-pattern-notes.md %})

#### [Iterator Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-iterator-pattern-notes.md %})

#### [Template Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-template-pattern-notes.md %})

#### [Visitor Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-visitor-pattern-notes.md %})

### 4.2 Structural Patterns

Structural design patterns are design patterns that **ease the design** by identifying a simple way to **realise relationships among entities**

#### [Composite Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-composite-pattern-notes.md %})

#### [Decorator Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-decorator-pattern-notes.md %})

#### [Adapter Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-adapter-pattern-notes.md %})

### 4.3 Creational Patterns

Creational patterns provide various **object creation mechanisms**, which **increase flexibility** and **reuse** of existing code

#### [Factory Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-factory-pattern-notes.md %})

provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.

#### [Abstract Factory Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-abstract-factory-pattern-notes.md %})

let users produce families of related objects without specifying their concrete classes.

#### [Builder Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-builder-pattern-notes.md %})

let users construct complex objects step by step. The pattern allows users to produce different types and representations of an object using the same construction code.

#### [Singleton Pattern]({{ site.baseurl }}{% link _posts/2021-07-28-singleton-pattern-notes.md %})

Let users ensure that a class has only one instance, while providing a global access point to this instance.

---

## 5. Project

**_Test Driven Development_**(TDD)

1. Design model (UML Diagram)
2. Write the class & Method stubs
3. Write unit tests
4. run the unit tests
5. implement the functions
6. pass the tests

---

### 5.1 Javafx

- Java’s original GUI library was the Abstract Window Toolkit (AWT)
- Swing was added to the platform in Java SE 1.2
- JavaFX is Java’s GUI, graphics and multimedia API
- JavaFX has better threading support, uses the GPU (graphics processing unit)
- JavaFX supports **transformations** for repositioning and reorienting JavaFX components, and **animations** for changing the properties of JavaFX c
- The **_Scene Builder_** tool is a standalone JavaFX GUI visual layout tool
- JavaFX Scene Builder enables you to create GUIs by dragging and dropping GUI components
- JavaFX Scene Builder generates `FXML` (FX Markup Language)—an XML vocabulary for defining and arranging JavaFX GUI controls without writing any Java code
- The FXML code is separate from the program logic that’s defined in Java source code—this separation of the interface (the GUI) from the implementation (the Java code) makes it easier to debug, modify and maintain JavaFX GUI apps

---

### 5.2 User Centred Design(UCD)

- **_Specify the context of use_**
  - Identify the people who will use the product(Persona)
  - what they will use it for
  - under what conditions(Scenario) they will use it
- **_Specify requirements_**
  - Identify any business requirements or user goals(Use-Cases) that must be met for the product to be successful
- **_Create design solutions_**
  - This part of the process may be done in stages, building from a rough concept to a complete design
- **_Evaluate designs_**
  - Evaluation - ideally through usability testing with actual users - is as integral, as quality testing is to good software development

> <details><summary>notes</summary>
> <p>
>
> - Agile Development philosophy provides value to customers, but in order for our software to be truly successful in the eyes of its biggest critics, we must adopt a more user-centered approach
> - UCD can be applied to the design of anything that has a user—from mobile phones to kitchens
> - The era of feature-centric development is coming to an end. Consumers are beginning to realize that more features do not always mean a better product. Quality of experience is far more likely to be a product differentiator than product features
> - UCD provides a way to engineer these quality experiences
>
> </p>
> </details>

> <details><summary>Jakob’s Ten Usability Heuristics (Nielsen Norman Group)</summary>
> <p>
>
> 1.  visibility of system status
> 2.  match between system and the real world
> 3.  user control and freedom
> 4.  consistency and standards
> 5.  error prevention
> 6.  recognition rather than recall
> 7.  flexibility and efficiency of use
> 8.  aesthetic and minimalist design
> 9.  recognise, diagnose, and recover from errors
> 10. help and documentation
>
> </p>
> </details>

---

### 5.3 Model-View-Controller (MVC)

MVC inserts a `controller` class between the `view` and `model` and **decouples** the two tiers, thereby making the `model` and `view` components **reusable without modification**


#### View

- The **presentation layer** that provides interaction that the user sees(e.g. a web page)
- View component takes **inputs** from the user and sends **actions** to the `controller` for manipulating data
- View is responsible for **displaying results** obtained by the `controller` from the `model` component in a way that user wants them to see or a pre-determined format(e.g. HTML, XML)
- View can query the `model` for updates
- It is responsibility of the `controller` to choose a `view` to display data to the user

#### Model(Data)

- Holds all the data, state
- Responds to instructions to change of state(from the `controller`)
- Responds to requests for information about its state(usually from the `view`)
- Sends notifications of state changes to “observer”(`view`) (this “push” behaviour may not always happen)
- The model does **NOT** depend on `controller` or `view`

#### Controller

- Glue between user and processing(`Model`) and formatting(`View`) logic
- Accepts the user **request** or **inputs** to the application, parses them and decides which type of `Model` or `View` should be invoked
- Provides `model` data to the `view`

---

### 5.4 Defensive Programming

- Tries to address unforeseen circumstances, in order to ensure the continuing functionality of the software element
  - For example, it makes the software behave in a predictable manner despite unexpected inputs or user actions
- often used where **high availability**, **safety or security** is needed
- results in **redundant checks**(both client and supplier may perform checks), more **complex software** for maintenance
- **difficult to locate errors**, considering there is **no clear demarcation** of responsibilities
- may safeguard against errors that will never been countered, thus **incurring run-time and maintenance costs**

---

### 5.5 Design by Contract(DbC)

- At the design time, **responsibilities** are **clearly assigned** to different software elements, clearly documented and enforced during the development using unit testing and/or language support
- clear demarcation of responsibilities helps **prevent redundant checks**, resulting in **simpler code and easier maintenance**
- crashes if the required conditions are not satisfied, may **not be suitable** for **high availability** applications
- **Bertrand Meyer** coined the term for his design of the **Eiffel programming language** (in 1986). `Design by Contract` has its roots in work on formal specification, formal verification and Hoare logic
- Every software element should define a specification/contract that governs its interaction with the rest of the software components
- A `contract` should address: pre-condition, post-condition, invariant
  - **declarative** and must **not** include implementation details
  - as far as possible: precise, formal and verifiable
- `Java` **does not** have **native support** for DbC, there are various libraries to support DbC
  - In the absence of a native language support, unit testing is used to test the contracts
  - Some programming languages (Eiffel) offer native support for DbC

> <details><summary>benefits</summary>
> <p>
>
> - Do **not need to do error checking** for conditions that not satisfy the `preconditions`
> - **Prevents** redundant validation tasks
> - Given the preconditions are satisfied, clients can **expect** the specified `post-conditions`
> - Responsibilities are **clearly assigned**, this helps in locating errors and resulting in easier code maintenance
> - Helps in **cleaner** and **faster** development
>
> </p>
> </details>

|          | Obligations                                                                                                                                                                       | Benefits                                                                                                                         |
| :------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------- |
|  Client  | must ensure `precondition`<br />- Be at the Santa Barbara airport at least 5 minutes before scheduled departure time<br />- Bring only acceptable baggage<br />- Pay ticket price | may benefit from `post-condition`<br />- Reach Chicago                                                                           |
| Supplier | must ensure `post-condition`<br />- Bring customer to Chicago                                                                                                                     | may assume `pre-condition`<br />- No need to carry passenger who is late, has unacceptable baggage, or has not paid ticket price |

---

#### Pre-condition - what does the contract expect?

- If the `pre-condition` is true, it can avoid handling cases outside of the `pre-condition`
- A `pre-condition` is a condition/predicate that **must always be true** just prior to the execution of some section of code
- If a `pre-condition` is violated, the effect of the section of code becomes undefined and thus may or may not carry out its intended work
- **Security problems** can arise due to **incorrect** `pre-conditions`
- Often, `pre-conditions` are included in the documentation of the affected section of code
- `Pre-conditions` are sometimes tested using **guards** or **assertions** within the code itself, and some languages have specific syntactic constructions for testing
- In `DbC`, a software element can assume that `pre-conditions` are satisfied, resulting in removal of redundant error checking code

> **_Pre-Conditions in Inheritance_**
>
> - An implementation or redefinition(`method overriding`) of an inherited method must comply with the inherited contract for the method
> - `Pre-conditions` may be **weakened/relaxed** in a `subclass`, but it must comply with the inherited contract
> - An implementation or redefinition **may lessen the obligation** of the client, but not increase it

---

#### Post-condition - what does the contract guarantee?

- Return value is guaranteed, provided the `pre-condition` is true
- A `post-condition` is a condition/predicate that **must always be true** just after the execution of some section of code
- The `post-condition` for any routine is a declaration of the properties which are **guaranteed** upon completion of the routine's execution
  - Meyer, Bertrand, Object-Oriented Software Construction, second edition, Prentice Hall, 1997
- Often, `pre-conditions` are included in the documentation of the affected section of code
- `Post-conditions` are sometimes tested using **guards** or **assertions** within the code itself, and some languages have specific syntactic constructions for testing
- In `DbC`, the properties declared by the `post-condition` are assured, provided the software element is called in a state in which its `pre-condition` were true.

> **_Post-Conditions in Inheritance_**
>
> - An implementation or redefinition(`method overriding`) of an inherited method must comply with the inherited contract for the method.
> - `Post-conditions` may be **strengthened/more restricted** in a `subclass`, but it must comply with the inherited contract
> - An implementation or redefinition(`overridden method`) **may increase the benefits** it provides to the client, but not decrease it

---

#### Invariant - what does the contract maintain?

- Some values must satisfy `constraints`, before and after the execution
- The `class invariant` constrains the state(i.e. values of certain variables) stored in the object
- `Class invariants` are **established during construction** and **constantly maintained between calls to public methods**, methods of the class must make sure that the class invariants are satisfied/preserved
- **Within a method**: code within a method **may break** `invariants` as long as the invariants are **restored** before a public method ends
- `Class invariants` help programmers to rely on a **valid state**, **avoiding risk of inaccurate/invalid data,** also helps in **locating errors** during testing

> **_Class invariants in Inheritance_**
>
> - `Class invariants` are inherited, that means, "the invariants of all the `parents` of a class apply to the class itself”
> - A `subclass` can access implementation data of the `parents`, however must always satisfy the `invariants` of all the parents – **preventing invalid states**

---

#### Exception

- Consider your `exception-handling` and `error-recovery strategy` in the **design process**
- Sometimes you can **prevent** an `exception` by **validating data** first
- If an `exception` can be handled meaningfully in a method, the method should **catch the exception** rather than declare it
- If a `subclass` method `overrides` a `superclass` method, a `subclass`’s **throws clause** can contain a **subset** of a `superclass`’s **throws clause**, it must not throw more `exceptions`
- Programmers should handle checked `exceptions`
- If **unchecked** `exceptions` are **expected**, you must handle them gracefully
- Only the first matching catch is executed, so select your catching class(es) carefully
- `Exceptions` are part of an API documentation and contract
- `Assertions` can be used to check `pre-conditions`, `post-conditions` and `invariants`

---

## 6. Java

---

### 6.1 Generics

Generics enable **types**(classes and interfaces) to be parameters when defining, `classes`, `interfaces` and `methods`

- Benefits
  - **Removes casting** and offers **stronger type checks** at **compile time**
  - Allows implementations of **generic algorithms**, that work on `collections` of **different types**, can be customised, and are type safe
  - **Adds stability** to your code by making more of your **bugs detectable** at **compile time**
- The relationship between the `type` parameters of one `class` or `interface` and the `type` parameters of another are determined by the `extends` and `implements` clauses
- You can subtype a generic `class` or `interface` by `extending` or `implementing` it
  - `ArrayList<E> implements List<E>`, and `List<E> extends Collection<E>`
  - So `ArrayList<String>` is a **subtype** of `List<String>`, which is a **subtype** of `Collection<String>`
- So long as you do not vary the type argument, the subtyping relationship is preserved between the types

---

#### Generic Type

- A `generic type` is a `generic class` or `interface` that is parameterised over types
- A generic class is defined with the following format
  - `class name< T1, T2, ..., Tn > { /* ... */ }`
- A generic class can have **multiple type parameters**
- The most commonly used type parameter names are:
  - `E` - Element(used extensively by the Java Collections Framework)
  - `K` - Key
  - `N` - Number
  - `T` - Type
  - `V` - Value
  - `S`,`U`,`V` etc. - 2nd, 3rd, 4th types

simple box class

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```

A Generic Version of the Box Class

```java
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

---

#### Generic Method

`Generic methods` are methods that **introduce** their **own type** parameters

```java
public class Util {
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) && p1.getValue().equals(p2.getValue());
    }
}

public class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
```

---

#### Bounded Type Parameters

restrict the type that can be used as type arguments in a parameterised type

- class
  ```java
  public class NaturalNumber<T extends Integer> {}
  ```
- method
  ```java
  public <U extends Number> void inspect(U u){
      System.out.println("U: " + u.getClass().getName());
  }
  ```
- multiple bounds

  - `B1`, `B2`, `B3` refer to `interfaces` or a `class`, there can be **at most one** `class` (single inheritance), and the **rest or all** will be `interfaces`
    ```java
    <T extends B1 & B2 & B3>
    ```
  - A type variable with multiple bounds is a `subtype` of all the types listed in the bound, if one of the bounds is a class, it must be specified first

    ```java
    Class A { /* ... */ }
    interface B { /* ... */ }
    interface C { /* ... */ }

    class D <T extends A & B & C> { /* ... */ }
    ```

---

#### Wildcard

**_In generic code, the question mark `?`, wildcard, represents an unknown type_**

- can be used as
  - type of a parameter
  - field
  - local variable
  - return type
- You can specify an **upper bound** for a wildcard, or you can specify a **lower bound**, but you **cannot specify both**
- Although Integer is a `subtype` of Number, `List<Integer>` is not a subtype of `List<Number>` and, these two types are not related
  - The **common parent** of `List<Number>` and `List<Integer>` is `List<?>`
- **_Upper Bounded_**
  - The upper bounded wildcard `< ? extends Foo >`, where `Foo` is any type, matches `Foo` and any **subtype** of `Foo`, using `extends` keyword
    ```java
    // The process method can access the list elements as type Foo
    public static void process(List<? extends Foo> list) {
        for (Foo elem : list) {
            // Any method defined in the Foo class can now be used on elem
        }
    }
    ```
- **_Lower Bounded_**
  - A lower bounded wildcard `< ? super A >`, using `super` keyword
  - The term `List<Integer>` is **more restrictive** than `List<? super Integer>`
    ```java
    public static void addNumbers(List<? super Integer> list) {
        for (int i = 1; i <= 10; i++) {
            list.add(i);
        }
    }
    ```
- **_Unbounded_**
  - The unbounded wildcard type is specified using the wildcard character `?`, eg. `List< ? >`
  - 2 approach
    - If you are writing a method that can be implemented using functionality provided in the Object class
    - When the code is using methods in the generic class that don't depend on the type parameter. For example, List.size or List.clear. In fact, Class<?> is so often used because most of the methods in Class<T> do not depend on T

---

### 6.2 Collections

- A **collections framework** is a unified architecture for representing and manipulating collections. A collection is simply an object that groups multiple elements into a single unit.
- `Interfaces`: allows collections to be manipulated independently of the details of their representation
  - The core collection interfaces encapsulate different types of collections
  - A Collection represents a group of objects known as its elements
  - The Collection interface is used to pass around collections of objects where maximum generality is desired
  - The Collection interface contains methods that perform basic operations
- `Implementations`: concrete implementations of the collection interfaces
- `Algorithms`: the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces
  - The algorithms are said to be **polymorphic**: that is, the same method can be used on many different implementations of the appropriate collection interface.


---

### 6.3 Code Smells

`Code Smells`: Structures in implementation of code such as large methods, classes with multiple responsibilities, complex conditional statements that lead to poor code

`Design Smells`: Design aspects at a higher level of abstraction (class level abstractions) such as classes with multiple responsibilities, refused bequest

- **Bloaters**: Code, Methods and classes that have grown in size, that they are hard to work with
  - Long Method, Large Class, Long Parameter List, Data Clumps
- **OO Abusers**: Result from incorrect or incomplete application of OO principles
  - Switch statements, Refused Bequest
- **Change Preventers**: Code changes are difficult (rigid code)
  - Divergent change, Shot Gun Surgery
- **Dispensables**: Code that is pointless and unnecessary
  - Comments, Data Class, Lazy Class, Duplicate code
- **Couplers**: Excessive coupling between classes
  - Feature Envy, Inappropriate intimacy, Message Chains

---

#### Code Smell Example

- deplicate code
  - same code structure in >1 place
  - same expression in 2 sibling classes
- Poor abstraction (change one place → must change others)
- Large loop, method, class, parameter list, deeply nested loop
  - Extract Method
  - Replace Temp With Query (move variable to a separate method)
  - Introduce Parameter Object
  - Preserve Whole Object
  - Replace Method with Method Object
- Class has too little cohesion
- Modules have too much coupling
- Feature Envy
- Class has poor encapsulation
- A subclass doesn’t use majority of inherited functionalities
- `Data class`: Classes that just have attributes with setters and getters and no behaviour
- `Lazy class`: Classes that aren’t doing much to justify their existence(maintenance overhead)
- `Switch Statement`: Switch statements are bad from an OO design point of view
  - Replace switch statements with a polymorphic solution based on **_Strategy Pattern_** applying a series of refactoring techniques
- Design is too specific / Design is unnecessarily general
- long parameter list
- divergent change
  - when one class is commonly changed in different ways for different reasons
- shotgun surgery
  - the opposite of divergent change
  - when making a lot of little changes to a lot of different classes

> <details><summary>List of Refactoring Techniques</summary>
> <p>
>
> - Move Field/Method
> - Extract Class/Inline Class
> - Extract Method
> - Inline Method/Temporary Variable
> - Replace Temp with Query
> - Replace Method with Method Object
> - Rename Method
> - Substitute Algorithm
> - Introduce Parameter Object
> - Preserve Whole Object
> - Extract Sub Class/Super Class/Interface
> - Extract Method
> - Pull Up Field/Method/Constructor Body
> - Form Template Method
> - Replace Inheritance with Delegation
> - Replace Conditional with Polymorphism
>
> </p>
> </details>

## References

- course COMP2511 - Object-Oriented Design & Programming
